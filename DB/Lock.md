## DataBase Lock

### 개념 이해

서로 다른 2개의 트랜잭션이 있다고 가정했을 때 세션1, 세션2가 생성된다.

**세션1**이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 **커밋**이 수행하지 않았는데,

**세션2**에서 동시에 같은 데이터를 수정하게되면 여러가지 문제가 발생한다. 바로 **트랜잭션의 원자성**이 꺠지는 것이다. 여기에 더해서 **세션1**이 중간에 **롤백**을 하게되면 세션2는 잘못된 데이터를 수정하게 되면서 문제가 발생한다.

이러한 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에 **커밋**이나 **롤백** 전까지

다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.


### 세션1 의 상황
- 세션1은 `memberA` 의 금액을 500원으로 변경하고 싶고, 세션2는 같은 `memberA` 의 금액을 1000원으로 변경하고 싶다.
- 이때 DB는 `Lock` 의 개념을 제공한다.

- 세션1이 트랜잭션을 시작한다.
- 세션1은 `memberA` 의 `money` 를 500원으로 변경을 시도한다 이때 해당 로우의  Lock을 먼저 획득해야한다. 
- `Lock`이 있으므로 `Lock`을 세션1이 획득한다.


### 세션2의 상황 
- 세션2는 트랜잭션을 시작한다.
- 세션2도 `memberA` 의 `money` 데이터를 변경하려고 시도한다. 이때 로우의 `Lock`을 먼저 획득해야 하는데 없으므로 기다린다.
- 그렇다고 무한정 대기하는 것은 아니고 Lock 대기시간이 넘어가면 Timeout 오류가 발생한다. `Lock` 대기시간은 설정할 수 있다.


```jsx
set autocommit false;
update member set money=500 where member_id = 'memberA';
```

세션1이 트랜잭션을 시작하고, `memberA` 의 데이터를 변경하고 커밋은 아직 하지 않았다. 

이떄는 세션1이  `memberA` 에 대한 Lock을 가지고 있게 된다.

```jsx
SET LOCK_TIMEOUT 60000;
set autocommit false;
update member set money=1000 where member_id = 'memberA';
```

세션 2가 `memberA` 의 데이터를 1000원으로 수정하려 하지만 세션1이 아직 커밋을 하지 않았기 때문에 Lock을 가지고 있어서 `Update SQL` 은 실행되지 않고 기다리게 된다. 

---

### DB 락 - 조회

일반적으로 조회는 `Lock`을 사용하지 않는다.

DB 마다 다르지만, 보통 데이터를 조회할 때는 `Lock`을 획득하지 않고 바로 데이터를 조회할 수 있다. 

**조회와 락**

데이터를 조회할 때도 `Lock`을 획득하고 싶을 떄가 있다. 이럴때는 `select for update` 구문을 사용하면 된다.

이렇게 하면 조회시점에 `Lock`을 가져가게 되므로 다른 세션에서 변경이 불가능해진다. 이 경우에도 **트랜잭션**을 커밋하면 Lock을 반납한다.

**조회 시점에 락이 필요하는 경우는??**

- 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
- 예를 들어 애플리케이션 로직에서 `memberA` 의 금액을 조회한 다음 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다. 그런데 이 계산이 돈과 관련된 중요한 계산이여서 완료할 떄 까지 수정이 있으면 안된다.
- 이럴 경우에 조회시점에 락을 획득하면 된다.
