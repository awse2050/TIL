
### 트랜잭션

**16.1.1 트랜잭션과 격리 수준**

`트랜잭션` 은 **ACID** 라 하는 **원자성, 일관성, 격리성, 지속성**을 보장해야 한다.

- `원자성` : 트랜잭션 내 실행한 작업은 모두 하나의 작업인 것처럼 모두 성공하던가 실패해야 한다.
- `일관성` : 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다.
- `격리성` : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 즉, 동시에 같은 데이터를 수정하지 못하게 해야 한다.
- `지속성` : 트랜잭션이 성공적으로 끝나면 그 결과는 항상 기록되어야 한다. 중간에 문제가 발생해도 DB 로그등을 사용해 성공한 트랜잭션 내용을 복구해야한다.

`트랜잭션` 은 **원자성, 일관성, 지속성**을 보장한다. 문제는 **격리성**인데, 

`트랜잭션` 간에 **격리성**을 완전히 보장하려면 `트랜잭션`을 거의 차례대로 

실행해야 한다. 이렇게 하면 동시성 처리 성능이 매우 나빠진다.

이러한 문제로 `ANSI` 표준은 트랜잭션 격리 수준을 4단계로 나누었다.

- **READ UNCOMMITED** ( 커밋되지 않은 읽기 )
- **READ COMMITED** ( 커밋된 읽기 )
- **REPEATABLE READ** ( 반복 가능한 읽기 )
- **SERIALIZABLE** ( 직렬화 가능 )

순서대로 **READ UNCOMMITED** 가 격리 수준이 가장 낮고 **SERIALIZABLE**의 격리 수준이 가장 높다.

격리 수준이 낮을 수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다. 

![트랜잭션 격리수준.PNG](https://github.com/awse2050/TIL/blob/main/DB/img/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80.PNG)


격리 수준에 다른 문제점은 다음과 같다.

- Dirty Read
- Non-REPEATABLE READ( 반복 불가능한 읽기 )
- Phantom Read

격리 수준이 낮을수록 더 많은 문제가 발생한다.


---


1) **Read Uncommited** : 커밋하지 않은 데이터를 읽을 수 있다.

예를들어 **트랜잭션1**이 데이터를 수정하고 있는데 커밋하지 않아도

**트랜잭션2**가 수정중인 데이터를 조회 할 수 있다.  ( = **Dirty Read**)

**트랜잭션2** 가 **Dirty Read** 한 데이터를 사용하는데 **트랜잭션1** 을 롤백하면

데이터 정합성에 문제가 발생할 수 있다.

**Dirty Read**를 허용하는 격리 수준을 **Read Uncommited** 라고 한다.

---

2) **Read Commited** : 커밋한 데이터만 읽을 수 있다.

따라서 **Dirty Read** 가 발생하지 않는다. 하지만 **Non-Repeatable Read**는 발생할 수 있다. 

예를 들어 **트랜잭션1** 이 회원 A를 조회 중인데 **트랜잭션2**가 회원 A를 수정하고 커밋하면 **트랜잭션1** 이 회원 A를 조회 했을 때 수정된 데이터가 조회 된다.

이처럼 반복해서 같은 데이터를 읽을 수 없는 상태를 **Non-Repeatable Read**라 한다.  **Dirty Read** 는 허용하지 않지만, **Non-Repeatable Read**는 허용하는 격리 수준이다.

---

3) **Repeatable Read** : 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 하지만 **Phantom Read** 는 발생 할 수 있다. 

예를 들어 **트랜잭션1** 이 10살 이하의 회원을 조회했는데 **트랝잭션2** 가 

5살 회원을 추가하고 커밋하면 **트랜잭션1**이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다. 

이처럼 조회시 결과 집합이 달라지는 것을 **Phantom Read** 라고한다.

**Non-Repeatable Read** 는 허용하지 않지만, **Phantom Read**는 허용하는 격리수준을 말한다.

---

4) **Serializable** : 가장 엄격한 트랜잭션 격리수준이다.

여기서는 **Phantom Read**가 발생하지 않는다. 하지만 **동시성 처리 성능**이

**급격히 떨어질 수 있다.**

애플리케이션 대부분은 **동시성 처리**가 중요하므로 DB들은 보통 

**Read Commited** 격리 수준을 기본적으로 사용한다.

일부 중요한 비즈니스 로직에 더 높은 격리 수준이 필요하면 DB 트랜잭션이 

제공하는 잠금 기능을 사용하면 된다.

---

[자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233)
