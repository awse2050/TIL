
### 다양한 연관관계

연관관계 매핑시 3가지를 고려하자.

+ 다중성 ( 연관관계 )
+ 단방향, 양방향
+ 연관관계의 주인


#### 1. 다중성

1) `N:1`
 
2) `1:N`
 
3) `1:1`

4) `N:N`

보통은 `N:1` , `1:N` 을 많이 사용하고,  `N:N` 은 실무에서 거의 사용하지 않는다.


다중성과 단방향, 양방향을 고려한 가능한 모든 연관관계

1) `N:1` : 단, 양

2) `1:N` : 단, 양

3) `1:1` : 주 테이블 단, 양

4) `1:1` : 대상 테이블 단, 양

5) `N:N` : 단, 양


####  2. `N:1` 단방향

테이블에서 외래 키는 항상 `N` 쪽에 있으므로 주인이 항상 `N` 이다


#### 3. `N:1` 양방향

외래 키를 관리하는 곳인 `N` 이 주인이다.

양방향이므로 서로 참조를  하고 있어야 한다.

양방향 관계는 서로 참조하기 떄문에 `연관관계 편의 메서드`를 작성하는 것이 좋다



#### 4. `1:N`  단방향

특이하게 반대편 테이블에 있는 외래 키를 관리한다.

항상 `N` 에서 외래 키를 가지고 있기 떄문이다.

이럴떄는 `@JoinColumn` 을 명시해야 하며, 그렇지 않을 경우 `조인 테이블 전략` 을 기본으로 사용해 매핑한다.

*즉, 중간 연결테이블이 하나 생긴다.*

```java
@OneToMany(mappedBy)
@JoinColumn(name="xxx")
private List list;
```

`1:N` 단방향은 다른 테이블의 외래 키를 관리해야 하여 **성능 문제** 가 있고 관리가 부담스러우므로

`N:1` 양방향 매핑을 사용하는 것이 좋다.

이 방법이 본인 테이블에 외래 키가 있어서 좀더 수월하다.

#### 5. `1:N` 양방향

이것은 존재하지 않다. `N:1` 양방향 매핑을 사용할 것.



#### 6. `1:1` 

양쪽 서로 하나의 관계만 가진다.

보통 `N` 쪽에서 외래 키를 관리하는 반면, `1:1` 은 외래 키 관리대상을 설정할 수 있다.


위치에 따라서 특징이 나뉜다.

+ 주 테이블에 외래 키가 있는 경우

: 외래 키를 객체 참조와 비슷하게 할 수 있어 객체지향 개발자가 선호한다.

+ 대상 테이블에 외래 키가 있는 경우

: 전통적인 DB 개발자가 선호한다.

`1:1` 에서 `1:N` 으로 변경할 떄 테이블 구조를 유지할수 있는 장점이 존재한다.



#### 7. `N:N` 단방향

객체와 다르게 DB는 정규화된 테이블 2개를 `N:N` 으로 표현할 수 없다.

그래서 `1:N`,  `N:1` 로 풀어내는 연결 테이블을 사용한다.

하지만,  객체는 2개로 `N:N` 을 `@ManyToMany`를 사용해서 만들 수 있다.

대신 `@JoinTable` 을 사용해서 만든다.

```java
@ManyToMany
@JoinTable(name = "MEMBER_PRODUCT",
			joinColumns = @JoinColumn(name = "MEMBER_ID"),
			inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"))
private List<Product> products = new ArrayList<Product>();
```

- `@JoinTable.name` : 연결 테이블을 지정한다.

- `JoinTablejoinColumns`:  현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정.

- `JoinTable.inverseJoinColumns`:  반대 방향인 상품과 매핑할 조인컬럼정보를 지정한다.




#### 8. `N:N` 양방향

양방향 또한 `@ManyToMany` 를 사용하며 주인을 설정해야 한다 (`mappedBy`)

```java
    @ManyToMany(mappedBy = "products")
    private List<Member> members = new ArrayList<>();
```


#### 9. `N:N` 매핑의 한계

`@ManyToMany` 를 사용하면 연결 테이블을 자동으로 처리하므로 도메인 모델이 단순해지지만 실무에서 쓰기에는 한계가 있다.

만약 추가적인 컬럼이 필요하다면? 더이상 이 어노테이션을 쓸 수 없다.

연결한 엔티티들은 추가한 컬럼들을 매핑할 수 없기 떄문이다.



#### 10. `N:N` 관계 정리

연결 테이블을 만들 때 식별자를 어떻게 구성할 지 정해야 한다.

+ `식별 관계`: 받아온 식별자를 기본 키 + 외래 키 로 사용한다.

+ `비식별 관계`: 받아온 식별자를 외래 키로만 사용하고 새로운 식별자를 추가한다.


객체 입장에서 보면  `비식별 관계` 로 사용하는 것이 복합 키를 위한 식별자 클래스를 만들지 않아도 되므로

단순하고 편리하게 ORM 매핑을 할 수 있다.






