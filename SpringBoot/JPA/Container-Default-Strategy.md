### 스프링 컨테이너의 기본 전략

스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트 전략**을 기본으로 사용한다.

말 그대로 `영속성 컨텍스트` 와 `트랜잭션` 범위가 생존범위가 같다는 의미이다.



1. 특징

+ `트랜잭션`을 시작할 때, `영속성 컨텍스트`를 생성하고 `트랜잭션`이 끝날 때, `영속성 컨텍스트` 를 종료한다.

+ 같은 `트랜잭션` 안에서는 항상 같은 `영속성 컨텍스트`에 접근한다.

---

스프링에서 보통 비즈니스 로직을 시작하는 계층에는 `@Transactional` 을 붙인다.

이 `Annotation` 이 있는 메서드는 실행 직전에 **스프링 트랜잭션 AOP** 가 실행된다.


2. 실행 과정

+ 대상 메서드가 실행되기 직전 `트랜잭션`을 시작하고 대상 메서드가 종료되면 `트랜잭션`을 `Commit` 하면서 종료한다.

+ `트랜잭션` 을 `Commit` 하면 `JPA` 가 먼저 영속성 컨텍스트를 `Flush` 한다.

+ `Flush` 를 통해 변경 내용을 DB에 반영 한 후, DB 트랜잭션을 `Commit` 한다.

따라서, `영속성 컨텍스트`의 변경 내용이 DB에 정상 반영된다.


만약 예외가 발생하면 `트랜잭션` 을 `Rollback` 하고 종료하는 데 이떄, `Flush`는 발생하지 않는다.



---



#### 같은 트랜잭션 범위.

트랜잭션 범위 내 영속성 컨텍스트 전략은 다양한 위치에서 매니저를 주입 받아 사용해도 `트랜잭션`이 같으면 항상 같은 `영속성 컨텍스트`를 사용한다. 

다음 그림에서 엔티티 매니저를 사용하는 두 코드가 모두 같은 범위의 트랜잭션에 있어 같은 영속성 컨텍스트를 사용한다.



#### 다른 트랜잭션 범위

여러 스레드에서 동시에 요청이 들어와 같은 `엔티티 매니저`를 사용해도` 트랜잭션`에 따라 접근하는 `영속성 컨텍스트`가 다르다.

사실 스프링 컨테이너는 스레드를 각각 다른 `트랜잭션`에 할당한다. 

따라서 같은 `엔티티 매니저`를 호출해도 다른 `영속성 컨텍스트`에 있어서 멀티스레드 상황에 안전햐다.

