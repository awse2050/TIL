# 람다 P.794~

`Java`에 는 큰 변화가 2번있었는데, 한 번은 `JDK1.5` 버전에서의 지네릭스이며, 또 한 번은 `JDK1.8` 에서의 람다식의 등장이다.

람다식의 도입으로 인해, 자바는 **객체지향언어 + 함수형 언어**가 되었다.

### 람다식이란?

`람다식` 은 간단히 말해서 메서드를 하나의 `식` 으로 표현하는 것이다.

`람다식`은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.

메서드를 `람다식` 으로 표현하면 메서드의 이름과 반환값이 없어지므로, `람다식` 을 `익명 함수` 라고도 한다.

```java
int[] arr = new int[5];
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5)+1);
```

여기서 `(i) -> (int)(Math.random() * 5)+1` 가 `람다식`이다.

이 `람다식`이 하는 일을 메서드로 표현하면 다음과 같다.

```java
int method() {
	return (int) (Math.random()*5) +1;
}
```

`람다식` 은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. `람다식` 으로 인해 메서드를 변수처럼 다루는 것이 가능.

### 람다식 작성

`람다식`은 `익명 함수` 답게 메서드에서 이름과 반환타입을 제거하고 매개변수의 **선언부**와 **몸통{}** 사이에 `->` 를 추가한다.

```java
반환타입 메서드 이름 (매개변수 선언) {}
=>   (매개변수 선언) -> {}
```

예로, 두 값 중에서 큰 값을 변환하는 메서드를 `람다식`으로 변환하면?

```java
int max(int a, int b) {
	return a > b ? a : b;
}
// 변환 후
(int a, int b) -> {
	return  a > b ? a : b;
}
```

반환값이 있는 메서드의 겨우, return문 대신 `식` 으로 대신 할 수 있다. `식` 의 연산결과가 자동적으로 반환값이 된다. 이때는 `문장` 이 아닌 `식`이므로 끝에 `;` 을 붙이지 않는다.

```java
(int a, int b) -> { return a > b ? a : b; }
// 변환 후
(int a, int b) -> a > b ? a : b;
```

`람다식` 에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있다.

대부분의 경우에 생략가능하다. `람다식`에 반환타입이 없는 이유도 항상 추론이 가능하기 떄문이다.

```java
(int a, int b) -> a > b ? a : b;
//변환 후
(a, b) -> a > b ? a : b;
```

아래와 같이 선언된 매개변수가 하나뿐일 경우 괄호를 생략할 수 있다.

단, 매개변수의 타입이 선언되어 있으면 괄호를 생략할 수 없다.

```java
(a) -> a+a   =>   a -> a+a // 가능
(int a) -> a+a    =>    int a -> a+a // 불가능
```

마찬가지로 `괄호{}` 안의 문장이 하나일 때는 생략할 수 있다. 이떄, 문장의 끝에 `;`를 붙이지 않아야 한다. 이때, `return` 문일 경우 생략이 불가능.

```java
(String name, int i ) -> {
	.....;
} 
// 변환 후
(String name, int i) -> .....;
```

### 함수형 인터페이스

```java
interface MyFunction {
	public int max(int a , int b);
}
```

이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같다

```java
MyFunction f = new MyFunction() {
  public int max(int a, int b) {
    return a > b ? a : b;
  }
};
int big = f.max(5, 3);
```

이렇게 만든 익명 객체를 `람다식`으로 표현할 수 있다.

```java
MyFunction f = (int a, int b) -> a > b ? a : b;
int big = f.max(5, 3);
```

`MyFunction` 인터페이스는 구현한 익명 객체를 `람다식`으로 대체 가능한 이유는 `람다식`도 실제고 익명 객체이며 이것을 구현한 `max()` 메서드와 `람다식`의 매배견수의 타입과 개수, 그리고 반환값이 일치하기 때문이다.

```java
@FunctionalInterface
interface MyFunction {
	public int max(int a, int b);
}
```

**함수형 인터페이스**에는 오직 하나의 **추상 메서드**만 있어야 하는 제약이 있다.

이떄 `static 메서드` 나 `default 메서드`의 개수는 상관이 없다.

### 함수형 인터페이스 타입의 매개변수와 반환타입

만약 다음과 같이 정의되어 있을 때, 매개변수의 타입이 `MyFunction` 타입이면, 그 메서드를 호출할 때 `람다식`을 참조하는 참조변수를 매개변수로 지정해야 한다는 뜻이다.

```java
// 인터페이스 선언
interface MyFunction {
	void myMethod();
}

void aMethod(MyFunction f) {
	f.myMethod();
}

MyFunction f = () -> System.out.println("myMethod()");
aMethod(f);
```

또는 참조변수 없이 직접 `람다식`을 매개변수로 지정하는 것이 가능하다.

```java
aMethod(() -> System.out.println("myMethod()"));
```

`람다식` 을 참조변수로 다룰수 있는 것은 메서드를 통해 `람다식`을 주고받을 수 있다는 것을 의미한다. 즉, **변수처럼 메서드**를 주고받는 것이 가능하다.

사실상 메서드가 아니라 객체를 주고 받는 것이라 근본적으로 달라지는 건 없지만 `람다식` 덕분에 예전보다 코드가 간결해졌다.

### 람다식의 타입과 형변환

**함수형 인터페이스**가 가지는 메서드의 몸통을 만들수 있는 구조가 다음에 쓰여있는 코드의 구조가 같기 때문에 형변환이 가능해진다.

```java
MyFunction f= (MyFunction) ( () -> {} );
```

여기서의 형변환은 사실 생략이 가능하다. 대신 `Object` 타입으로는 형변환이 불가능하며 `람다식` 은 오직 **함수형 인터페이스**로만 형변환이 가능하다.

```java
Object obj = (Object) ( () -> {} ) ; // 에러
```

굳이 쓸꺼면 **함수형 인터페이스**로 먼저 **명시적 형변환**을 해야 한다.
```java
(Object) (MyFunction) ( () -> {} );
```

