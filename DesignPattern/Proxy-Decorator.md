# Proxy vs Decorator


여기서 생각해보면 `Decorator` 기능에 일부 중복이 있다.

꾸며주는 역할을 하는 `Decorator` 들은 스스로 존재할 수 없다. 항상 꾸며줄 대상이 필요하다. 따라서 내부에 호출 대상인 `component` 를 가지고 있어야 한다.

그리고 `component` 를 항상 호출해야 한다. 이 부분이 중복이다.

이런 중복을 제거하기 위해서 `component` 속성을 가지는 `Decorator` 라는 추상클래스를 만드는 방법도 고안할 수 있다.

하지만, 우리가 만든 구조 또한 의도가 분명하기 떄문에 틀린 것은 아니다.

여기서 의문이 발생한다.

1. `Decorator` 라는 추상클래스를 만들어야 `데코레이터 패턴` 인가?
2. `프록시 패턴` 과 `데코레이터 패턴` 은 그 모양이 거의 비슷하다.

---

### 의도

사실 `프록시 패턴` 과 `데코레이터 패턴` 은 모양이 거의 같고, 상황에 따라 정말 같을 떄도 있다. 그러면 둘을 구분하는 방법은 ?

디자인 패턴에서 중요한 것은 **패턴의 겉모양이 아닌, 패턴을 만든 의도**가 더 중요하다.

따라서 그 `의도` 에 따라서 패턴을 구분한다.

- `프록시 패턴` : 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- `데코레이터 패턴` : 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안을 제공

**정리**

**접근 제어**가 목적이면 `프록시 패턴`, **새로운 기능 추가**가 목적이면 `데코레이터 패턴`
